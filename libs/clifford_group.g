
# obj: create mutable list:
identical_list := function(int,len)
        
        local lst,i;
        
        lst := [];
    
        for i in [1..Int(len)] do
            Add(lst,int);
        od;
        return lst;
end;


# input: n: integer: number of factors:
# input: A: matrix to take tensor of:
n_fold_tensor:=function(n,A)

    local An,i;

	if n = 0 then
		return 1;
	elif n = 1 then
		return A;
	else
    	An:= A;;

    	for i in [2..n] do
        	An:=KroneckerProduct(An,A);
    	od;
    	return An;
	fi;
end;

# generate Pauli matrix from bit string:
# use phase phi = ax*az
pauli_n:=function(ab)

    local x,z,Xa,Zb,n,a,b,arg_phase,phase,i;
    
    x:=[[0,1],[1,0]];;
    z:=DiagonalMat([1,-1]);;
    
    n:=Length(ab)/2;
    
    a:=ab{[1..n]};;
    b:=ab{[n+1..(2*n)]};;
    
    Xa:=x^(a[1]);;
    Zb:=z^(b[1]);;
    
    if n > 1 then
        for i in [2..Int(n)] do
            Xa := KroneckerProduct(Xa,x^(a[i]));;
            Zb := KroneckerProduct(Zb,z^(b[i]));;
        od;
    fi;
    
    arg_phase := (a*b mod 4);
    phase := E(4)^arg_phase;

    return phase*Xa*Zb;
end;

# generate Pauli group:
Pauli_group := function(n)
    
    local x,y,z,P_lst,i,zeros;#x_lst,y_lst,z_lst,x,y,z,Xi,Yi,Zi,P_lst;
    
    #x_lst := [];; y_lst := [];; z_lst := [];;

	P_lst := [];

	zeros := identical_list(0,Int(2*n));

    
    for i in [1..Int(n)] do
        
        # create Pauli binary strings:
        
        x := StructuralCopy(zeros);;
        x[Int(i)]:=1;;
        
        z := StructuralCopy(zeros);;
        z[Int(i+n)]:=1;;
    
        y := x+z;;
        
        #Xi := pauli_n(x);; Yi := pauli_n(y);; Zi := pauli_n(Z);; 
        Add(P_lst,pauli_n(x));; Add(P_lst,pauli_n(y));; Add(P_lst,pauli_n(z));;
    od;
    #P_lst := x_lst;; Append(P_lst,y_lst);; Append(P_lst,z_lst);;
    return Group(P_lst);
end;

# Quotient Pauli group by center:
Pauli_quotient_group := function(P)
	return FactorGroup(P,Center(P));
end;

# generate hadmard unitary gate on the jth qubit:
hadamard_j := function(j,n)
	local identity, Hj, H,i;

	identity := DiagonalMat([1,1]);;
	H := [[1,1],[1,-1]]; H := H/ER(2);

	if (j = 1) then
		Hj := H;
	else
		Hj := identity;
	fi;

	if (n = 1) then
		return Hj;
	else
		for i in [2..n] do
			if not (i = j) then
				Hj := KroneckerProduct(Hj,identity);

			else
				Hj := KroneckerProduct(Hj,H);
			fi;
		od;
		return Hj;
	fi;
end;

# generate phase unitary gate on jth qubit:
phase_j := function(j,n)
	local identity, Pj, P,i;

	identity := DiagonalMat([1,1]);;
	P := DiagonalMat([1,E(4)]);

	if (j = 1) then
		Pj := P;
	else
		Pj := identity;
	fi;

	if (n = 1) then
		return Pj;
	else
		for i in [2..n] do
			if not (i = j) then
				Pj := KroneckerProduct(Pj,identity);

			else
				Pj := KroneckerProduct(Pj,P);
			fi;
		od;
		return Pj;
	fi;
end;



# generate cnot unitary (hermititan) gate on control c and target t qubits:
cnot := function(c,t,n)
	local Proj00, Proj11, XX, I, CX1,CX2,CX;

	I := DiagonalMat([1,1]);;
	Proj00 := DiagonalMat([1,0]);;
	Proj11 := DiagonalMat([0,1]);;
	XX := [[0,1],[1,0]];;

	if (n = 1) then
		# not valid generator for single qubit:
		return I;
	else
		# if c is first qubit, initialize CX1/CX2 in Proj00/Proj11
		if c = 1 then
			# if control = 0, apply identity to target:
			CX1 := Proj00;
			CX1 := KroneckerProduct(CX1,n_fold_tensor(n-1,I));

			# if control = 1, apply X (not) gate to target:
			CX2 := Proj11;
			if (t-c) = 1 then 
				CX2 := KroneckerProduct(CX2,XX);
				if n = 2 then
					return CX1+CX2;
				fi;
				
				CX2 := KroneckerProduct(CX2,n_fold_tensor(n-t,I));

			else
				CX2 := KroneckerProduct(CX2,n_fold_tensor(t-c-1,I));
				CX2 := KroneckerProduct(CX2,XX);
			fi;

			return CX1+CX2;

		else; 
			CX1 := n_fold_tensor(c-1,I);
			CX1 := KroneckerProduct(CX1,Proj00);
			CX1 := KroneckerProduct(CX1,n_fold_tensor(n-c,I));

			CX2 := n_fold_tensor(c-1,I);
			CX2 := KroneckerProduct(CX2,Proj11);
			if (t-c) = 1 then 
				CX2 := KroneckerProduct(CX2,XX);
			else
				CX2 := KroneckerProduct(CX2,n_fold_tensor(t-c-1,I));
				CX2 := KroneckerProduct(CX2,XX);
			fi;

			if (n-t) > 1 then
				CX2 := KroneckerProduct(CX2,n_fold_tensor(n-t,I));
			fi;

			return CX1+CX2;
		fi;
	fi;
end;


# generate unitary clifford group as generated by <Hi,Pj,CXij>
# note it suffices to CX_ij such that i<j since CX_ji is implied by conjugation with Hadamard:
unitary_clifford_group := function(n)

	local gens,combs,i,c;

	gens := [];

	for i in [1..n] do
		Add(gens,hadamard_j(i,n)); Add(gens,phase_j(i,n));
	od;

	combs := Combinations([1..n],2);

	for c in combs do
		Add(gens,cnot(c[1],c[2],n));
	od;

	return Group(gens);

end;

# generate mappings (nat) to the quotient group (cln)
clifford_group := function(n)

	local CLn, nat;

	CLn := unitary_clifford_group(n);

	nat:=NaturalHomomorphismByNormalSubgroup(CLn,Center(CLn));;

	return [nat,Image(nat)];
end;



################################################################################################
#function for complex conjugate
#input matrix mat, output hermitian transpose of mat

dagger:=function(M)

local M_conj,M_dag;

M_conj:=ComplexConjugate(M);
M_dag:=TransposedMat(M_conj);

return M_dag;

end;


################################################################################################
# recursive function for all bit strings

all_bit_strings := function(N)

	local x,n,generate_bit_strings;

	x := [[0],[1]]; n := 1;

######################################
# recursive function:
######################################

		generate_bit_strings := function(M,m,s)

		local Z2, bit_strings, ZZ, Zz0, Zz1,i;

		ZZ := StructuralCopy(s);

		if n < N then
			bit_strings := []; Z2 := [0,1];
			for i in [1..Length(s)] do
				Zz0 := StructuralCopy(ZZ[i]);
				Zz1 := StructuralCopy(ZZ[i]);
				Add(Zz0,0);
				Add(Zz1,1);
				Add(bit_strings,Zz0);
				Add(bit_strings,Zz1);
			od;
			n := n+1;
			#Display(n); Display(bit_strings);
			return generate_bit_strings(N,n,bit_strings);
		else
			return s;
		fi;

		end;

######################################
######################################

	return generate_bit_strings(N,n,x);
end;


# SortBy(lst, function(v) return v*v; end);
# Parallel sort of lists?


################################################################################################
# organize bit strings into lexicographic order; i.e., i, i..ix, i...iy, etc.


bit_to_pauli_string := function(x)

    local i, n, strg;

    n := (Length(x)/2);
    strg := "";
    for i in [1..n] do
        if (x[i] = 0) and (x[i+n] = 0) then
            strg := Concatenation(strg,"i");
        elif (x[i] = 1) and (x[i+n] = 0) then
            strg := Concatenation(strg,"x");
        elif (x[i] = 0) and (x[i+n] = 1) then
            strg := Concatenation(strg,"z");
        elif (x[i] = 1) and (x[i+n] = 1) then
            strg := Concatenation(strg,"y");
        else
            return "error";
        fi;
    od;

    return strg;
end;

######################################

list_bit_to_pauli_string := function(E)

    local i, N, P_strgs;

    N := Length(E);
    P_strgs := [];

    for i in [1..N] do
        Add(P_strgs,bit_to_pauli_string(E[i]));
    od;

    # sort in lexicographic order:
    SortParallel(P_strgs, E);

    return [P_strgs,E];
end;

######################################

#input: pauli_list: list of strings; e.g., ["iii","iix",...];
#input: value_list: coefficients assigned Pauli in pauli_list
generate_pauli_coef := function(P_strings,pauli_list,value_list)

    local i,j,C;

    C := identical_list(0,Length(P_strings));;

    for i in [1..Length(pauli_list)] do
        for j in [1..Length(P_strings)] do
            if (pauli_list[i] = P_strings[j]) then
                C[j] := value_list[i]; 
            fi;
        od;
    od;
    return C;
end;


################################################################################################

pauli_matrices := function(En)

local Pn,i;

Pn := [];

for i in En do
	Add(Pn,pauli_n(i));
od;

return Pn;

end;




################################################################################################
#function for getting the vertices representative
#input a list of coeff w.r.t. the pauli basis, then output the corresponding matrix (notice that this function only work for 2 copies of pauli matrix
#coeff in order [ii,ix,iy,iz,xi,xx,xy,xz,yi,yx,yy,yz,zi,zx,zy,zz]

coeff_to_mat:=function(C,Pn)

local mats, mat,c;

if Size(C)<>(Size(Pn)) then Display("error");return;fi;

#Pn := pauli_matrices(En);

mats :=[];
for c in [1..Length(Pn)] do
	Add(mats,C[c]*Pn[c]);
od;

mat:=Sum(mats);

return mat;
end;



################################################################################################
#function for clifford action
#input clifford 2 group element g and a herm mat, output the g\cdot mat 

cliff_act_mat:=function(Nat,G,g,M)

local gg,mat;

gg:=PreImagesRepresentative(Nat,g);
mat:=gg*M*dagger(gg);

return mat;
end;


################################################################################################

#input a hermitian matrix
#output its coeff w.r.t the pauli basis

mat_to_coeff:=function(M,Pn)

local A, C, N;

N := DimensionsMat(Pn[1])[1];

C := [];

for A in Pn do
	Add(C,Trace(M*A)/N);
od;


return C;

end;



################################################################################################
#function for clifford action
#input clifford 2 group element g and a coeff in paulis basis, output the g\cdot coeff 

cliff_act_coeff:=function(Nat,G,g,C,Pn)

local im,mat,im_coeff;


mat:=coeff_to_mat(C,Pn); # coeff_to_mat:=function(C,En)
im:=cliff_act_mat(Nat,G,g,mat);
im_coeff:=mat_to_coeff(im,Pn);

return im_coeff;
end;





################################################################################################
################################################################################################






clifford_orbit := function(Nat,G,C,En)

local orb,g,im,Pn;

Pn := pauli_matrices(En);

orb:=[];;
for g in G do
	im:=cliff_act_coeff(Nat,G,g,C,Pn);
	if (im in orb)=false then Add(orb,im);fi;
od;

return orb;

end;


symplectic_matrix := function(n)

    local mat,diagonal,a,i,j;

    diagonal := [];

    for a in [1..(2*n)] do  
        Add(diagonal,0*Z(2));
    od;

    mat := DiagonalMat(diagonal);

    for i in [1..(2*n)] do
        if i <= n then
            mat[i,n+i] := Z(2)^0;
        elif i > n then
            mat[i,i-n] := Z(2)^0;
        fi;
    od;

    return mat;

end;


symplectic_orbit_subspace := function(n,subspace)

    local orb, g, SPn, im_subspace, v, im_v, e, form,mat;

    mat := symplectic_matrix(n);

    form := BilinearFormByMatrix(mat,GF(2));

    SPn := SymplecticGroup(2*n,2,form);

    orb := [];
    for g in SPn do
        im_subspace := Set([]);;
        for v in subspace do
            im_v := [];;
            for e in (g*v) do Add(im_v,Int(e)); od;
            AddSet(im_subspace,im_v);
        od;
        if (im_subspace in orb) = false then
            Add(orb,im_subspace);
        fi;
    od;

    return orb;
end;
















