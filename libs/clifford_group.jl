using GAP
using LinearAlgebra
using Combinatorics

const g = GAP.Globals
const gjl = GAP.gap_to_julia
const jlg = GAP.julia_to_gap;

include("utils.jl"); include("pauli.jl")


R2 = (g.E(8)+(g.E(8))^7)        # root 2 using roots of unity
Id = jlg([1 0; 0 1])            # identity
P = jlg([1 0; 0 g.E(4)])        # Phase gate
H = 1/R2*jlg([1 1; 1 -1])       # Hadamard gate
CNOT = jlg([1 0 0 0; 0 1 0 0;   # CNOT gate
            0 0 0 1; 0 0 1 0])



function hadamard_j(j::Int, n::Int)

    if j == 1
        Hj = H
    else
        Hj = Id
    end

    if n == 1
        return Hj
    else
        for i in 2:n
            if i != j
                Hj = g.KroneckerProduct(Hj, Id)
            else
                Hj = g.KroneckerProduct(Hj, H)
            end
        end
        return Hj
    end
end

function phase_j(j::Int, n::Int)

    if j == 1
        Pj = P
    else
        Pj = Id
    end

    if n == 1
        return Pj
    else
        for i in 2:n
            if i != j
                Pj = g.KroneckerProduct(Pj, Id)
            else
                Pj = g.KroneckerProduct(Pj, P)
            end
        end
        return Pj
    end
end

function cnot(c::Int, t::Int, n::Int)
    Proj00 = g.DiagonalMat(jlg([1, 0]))
    Proj11 = g.DiagonalMat(jlg([0, 1]))
    NOT = jlg([0 1; 1 0])

    if n == 1
        # Not a valid generator for single qubit
        return Id
    else
        # If c is the first qubit, initialize CX1/CX2 in Proj00/Proj11
        if c == 1
            # If control = 0, apply identity to target
            CX1 = g.KroneckerProduct(Proj00, n_fold_tensor(n-1, Id))

            # If control = 1, apply X (not) gate to target
            if (t - c) == 1
                CX2 = g.KroneckerProduct(Proj11, NOT)
                if n == 2
                    return CX1 + CX2
                elseif n > 2
                    CX2 = g.KroneckerProduct(CX2, n_fold_tensor(n-t, Id))
                end
            elseif (t-c) > 1
                CX2 = g.KroneckerProduct(Proj11,n_fold_tensor(t-c-1, Id))
                CX2 = g.KroneckerProduct(CX2,NOT)
                CX2 = g.KroneckerProduct(CX2,n_fold_tensor(n-t, Id))
            end

            return CX1 + CX2
        else
            CX1 = g.KroneckerProduct(n_fold_tensor(c-1, Id), Proj00)
            CX1 = g.KroneckerProduct(CX1, n_fold_tensor(n-c, Id))

            CX2 = g.KroneckerProduct(n_fold_tensor(c-1, Id), Proj11)
            if t - c == 1
                CX2 = g.KroneckerProduct(CX2, NOT)
            else
                CX2 = g.KroneckerProduct(n_fold_tensor(t-c-1, Id), NOT)
                CX2 = g.KroneckerProduct(CX2, n_fold_tensor(n-t, Id))
            end

            return CX1 + CX2
        end
    end
end


# Helper function to compute tensor product of n matrices
function n_fold_tensor(n::Int, mat)
    if n == 0
        return g.DiagonalMat(jlg([1]))
    elseif n == 1
        return mat
    elseif n > 1
        result = mat
        for i in 1:n-1
            result = g.KroneckerProduct(result, mat)
        end
    end
    return result
end



function unitary_clifford_group(n)
    gens = []

    for i in 1:n
        push!(gens, hadamard_j(i, n))
        push!(gens, phase_j(i, n))
    end

    combs = collect(combinations(1:n, 2))

    for c in combs
        push!(gens, cnot(c[1], c[2], n))
    end

    gens = jlg(gens)

    return g.Group(gens)
end


mutable struct Group
    """
    Structure to store a pauli strings, bit strings, and dictionary mapping between the two 

    Attributes:
    GroupObj: GAP group object
    Order: Order of finite group
    Generators: Generators of Group
    Elements: Elements of Group
    """
    Grp::GapObj
    Order::Int64
    Gens::GapObj
    #Elements::GapObj

    function Group(G::GapObj)
        """
        Constructor for the UnitarySubGroups structure that creates Pauli and Normalizer of Pauli unitary matrix groups.
        """
        Grp = G
        Order = g.Order(G)
        Gens = g.GeneratorsOfGroup(G)
        #Elements = g.Elements(G)
        new(Grp,Order,Gens)
    end
end


mutable struct CliffordGates
    """
    Structure to store a pauli strings, bit strings, and dictionary mapping between the two 

    Attributes:
    PauliGroup: finite subgroup of unitary group generated by Pauli operators
    NormalizerGroup: finite subgroup of unitary generated by Hadamard, Phase, and CNOT
    """
    PauliGates::Group
    NormalizerGates::Group

    function CliffordGates(n::Int)
        """
        Constructor for the CliffordGates structure that creates Pauli and Normalizer of Pauli unitary matrix groups.
        """
        PauliGates = Group(Pauli_group(n))
        NormalizerGates = Group(g.Normalizer(unitary_clifford_group(n),PauliGates.Grp))
        new(PauliGates,NormalizerGates)
    end
end



################################################################################################


function clifford_group(CG::CliffordGates)
    P = CG.PauliGates.Grp; C = CG.NormalizerGates.Grp

    hom = g.ActionHomomorphism(C,P)
    Cl = hom(C)

    return Group(Cl), hom

end


function pauli_to_action_domain_mappings(P::PauliString,G::GapObj)
    E = P.bit_strings; bit_to_int = P.bit_to_int;
    F = [f for f in g.Elements(G)]
    N = length(F); n = Int64(log(4,N)-1);

    X = Vector{Int64}([]); Y = Vector{Int64}([]);
    for a in E
        for s in [0,1]
            Ta = jlg((-1)^s)*pauli_n(a)
            x = bit_to_int[a]+s*2^(2*n); push!(X,x)
            y = findall(w->w == Ta,F)[1]; push!(Y,y)
            #z = findall(w->w == map(E1[y]),E2)[1]; 
        end
    end

    int_to_action_domain = Dict(zip(X,Y))
    action_domain_to_int = Dict(zip(Y,X))


    return int_to_action_domain, action_domain_to_int

end


mutable struct CliffordGroup
    """
    Structure to store Clifford group, normal subgroup used to define action homomorphism, etc.

    Attributes:
    CliffordGroup:      Automorphisms of ActionSubgroup
    PauliGroup:         Isomorphic to ActionSubgroup
    ActionSubgroup:     Normal Subgroup of Clifford group that is isomorphic to PauliGroup
    PauliActionIso:     Isomorphism between Pauli group and normal subgroup used for action homomorphism
    GateGroupHom:       Homomorphism between normalizer of Pauli group and Clifford group
    IntActionDict:      Dictionary mapping Hermitian paulis (indexed 1..4^n/2) and action domain
    ActionIntDict:      Dictionary with reverse mapping

    """
    PauliInfo::PauliString
    NormalizerGates::Group
    PauliGates::Group
    CliffGroup::Group
    GateGroupHom::GapObj
    IntActionDict::Dict{Int,Int}
    ActionIntDict::Dict{Int,Int}

    function CliffordGroup(n::Int)
        """
        Constructor for the CliffordGroup structure
        """
        CG = CliffordGates(n); PauliInfo = PauliString(n)

        NormalizerGates = CG.NormalizerGates
        PauliGates = CG.PauliGates

        CliffGroup, GateGroupHom = clifford_group(CG)

        IntActionDict, ActionIntDict = pauli_to_action_domain_mappings(PauliInfo,PauliGates.Grp)

        new(PauliInfo,NormalizerGates,PauliGates,CliffGroup,GateGroupHom,IntActionDict,ActionIntDict)
    end
end



################################################################################################

"""
function grouping(V::Vector)
    keys = Vector{Int}([]); N = length(V)
    values = Vector([])

    for i in 1:N
        push!(values,abs(V[i]))
        if abs(V[i]) == V[i]
            push!(keys,i)
        else
            push!(keys,i+N)
        end
    end
    return Dict(zip(keys,values))
end
""";;

function grouping(C::Vector{<:Number})
    # Find non-zero coefficients and their indices
    non_zero_indices = findall(!iszero, C)
    non_zero_coefficients = abs.(C[non_zero_indices])

    # Values of non-zero coefficients
    elements = unique(non_zero_coefficients)
    sort!(elements)

    # Map coefficients to element in set and create dictionary
    cdict = Dict()
    idx = 0
    for e in elements
        if !(e in keys(cdict))
            idx += 1
            cdict[e] = idx
        end
    end

    # Create array of sets to store subsets
    subsets = Vector{Set{Int}}(undef, length(elements))
    coefficient_dict = Dict{Real,Int}()

    for (i, coeff) in enumerate(non_zero_coefficients)
        subset_index = cdict[coeff]
        if isassigned(subsets, subset_index)
            if C[non_zero_indices[i]] >= 0
                push!(subsets[subset_index], non_zero_indices[i])
            else
                push!(subsets[subset_index], non_zero_indices[i] + length(C))
            end
        else
            if C[non_zero_indices[i]] >= 0
                subsets[subset_index] = Set([non_zero_indices[i]])
            else
                subsets[subset_index] = Set([non_zero_indices[i] + length(C)])
            end
        end
        coefficient_dict[coeff] = subset_index
    end

    # Sort by increasing order of set
    sorted_subsets, sorted_elements = sortperm(elements), elements[sortperm(elements)]
    subsets = [subsets[i] for i in sorted_subsets]

    return sorted_elements, subsets, coefficient_dict
end



function subset_to_vector(N::Int,S::Vector{Vector{Int64}},dict::Dict{Real,Int})
    map = reverse_map(dict)
    V = Vector{Real}([0 for i in 1:N])
    for i in 1:length(S)
        subset = S[i]; abs_val = map[i]
        for s in subset
            if s <= N
                val = abs_val; idx = s;
            else
                val = -abs_val; idx = s-N;
            end;
            V[idx] = val;
        end
    end
    return V
end










function clifford_orbit_of_point(CG::CliffordGroup,C::Vector)
    C = Vector{Real}(C)
    fdict = CG.IntActionDict
    bdict = CG.ActionIntDict
    G = CG.CliffGroup.Grp
    N = length(C); S = g.Set(jlg([]))

    vals, V, map = grouping(C)

    for v in V
        global s = g.Set(jlg([]));
        for e in v
            g.Add(s,jlg(fdict[e])); 
        end
        s = g.Set(s); g.Add(S,s)
    end

    S = g.Set(jlg([S]))
    Orbs = g.Orbits(G,S,g.OnSetsSets)[1]

    #println(Orbs)
    
    VOrb = Vector{Vector{Real}}([])
    for orb in Orbs
        orbit = Vector{Vector{Int}}([])
        for s in orb
            subset = Vector{Int}([bdict[elem] for elem in s])
            push!(orbit,sort(subset))
        end

        vorb = subset_to_vector(N,orbit,map)
        push!(VOrb,vorb)
    end
    

    return VOrb
end




function clifford_gate_action_on_point(gens,CG::CliffordGroup,C::Vector)
    C = Vector{Real}(C)
    fdict = CG.IntActionDict
    bdict = CG.ActionIntDict
    G = CG.CliffGroup.Grp
    N = length(C);
    K = g.Set(jlg([]))

    gg = g.GeneratorsOfGroup(G)[gens[1]];
    for i in gens[2:end]; gg = gg*g.GeneratorsOfGroup(G)[i]; end;

    vals, V, map = grouping(C)

    K = Vector{Vector{Int}}([])
    for v in V
        k = Vector{Int}([]);
        for e in v
            x = e; y = fdict[e]; gy = g.OnPoints(jlg(y),gg); gx = bdict[gy];
            #println("$x, $y, $gy, $gx")
            push!(k,gx); 
        end
        push!(K,k)
    end

    return subset_to_vector(N,K,map)
end


























"""
# OLD FUNCTIONS

# read gap script:
@gap("Read(\"libs/clifford_group.g\");;");

@gap("LoadPackage(\"forms\");;");

function clifford_group(n)

    n_string = string(n);
    GAP.evalstr("n:= "*string(n)*";;");
    GAP.evalstr("cl"*n_string*"_pair := clifford_group(n);;");
    GAP.evalstr("nat"*n_string*" := cl"*n_string*"_pair[1];;");
    GAP.evalstr("cl"*n_string*" := cl"*n_string*"_pair[2];;");
end

function pauli_to_bit_strings(n)
    n_string = string(n);
    GAP.evalstr("n := "*n_string*";");
    GAP.evalstr("E"*n_string*" := all_bit_strings(2*n);");
    GAP.evalstr("P"*n_string*"_pair := list_bit_to_pauli_string(E"*n_string*");;");
    Pn_string = (GAP.gap_to_julia(GAP.evalstr("P"*n_string*"_pair[1];")));
    En = (GAP.gap_to_julia(GAP.evalstr("P"*n_string*"_pair[2];")));

    return Pn_string, En;
end



function generate_pauli_coefficients(pauli_keys,input_pauli,input_values)

    # generate dictionary between paulis and index 1,...,4^n:
    idx_list = [i for i in 1:length(pauli_keys)];
    dict = Dict(zip(pauli_keys,idx_list));

    pauli_idx = [dict[A] for A in input_pauli];

    C = [0 for i in 1:length(pauli_keys)];

    C[pauli_idx] .= input_values;

    return C
end


function generate_rational_coefficient_string(C)
    # convert to julia rational vector
    C = Vector{Rational{Int64}}(C);
    # convert to string and remove "Rational{Int64}:" characters:
    C_string = string(C)[16:end];

    # initialize output string:
    S = ""; 
    for i in 1:length(C_string)
        if (C_string[i] == '/') && (C_string[i+1] == '/')
            continue;
        end;
        S = S*C_string[i];
    end
    return S
end

# NOTE: should have previously generated clifford group:
function clifford_orbit(C,n)
    nn = string(n);

    # only works for rational inputs:
    CC = generate_rational_coefficient_string(C);

    C_orbit = GAP.evalstr("clifford_orbit(nat"*nn*",cl"*nn*","*CC*",E"*nn*")");

    return GAP.gap_to_julia(C_orbit);
end



# convert array to matrix:
# assume elements are vectors of same length:
function array_to_matrix(typ, arry)
    n = length(arry); d = length(arry[1]);
    # intialize matrix:
    M = Matrix{typ}(undef, 0, d);
    for i in 1:n
        M = vcat(M,transpose(arry[i]));
    end;
    return M
end


# convert array to polymake matrix:
# input: typ: pm.Rational, pm.Integer, etc.
# input: julia array:
function array_to_polymake_matrix(typ, arry)
    M = array_to_matrix(typ,arry);
    return pm.Matrix{typ}(M)
end

""";